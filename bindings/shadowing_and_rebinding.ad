public fn main()
{
    value_type_rebinding();
    value_type_shadowing();
    value_type_not_shadowing();
    value_type_control_flow_not_rebinding(true);

    reference_type_rebinding();
    reference_type_shadowing();
    reference_type_not_shadowing();
    reference_type_control_flow_not_rebinding(true);
}

public fn value_type_rebinding()
{
    {
        let x: int = 1;
        let x: int = 2;
    }
    {
        let x: int = 1;
        var x: int = 2; // ERROR
    }
    {
        var x: int = 1;
        let x: int = 2; // ERROR
    }
    {
        var x: int = 1;
        var x: int = 2; // ERROR
    }
}

public fn value_type_shadowing()
{
    {
        let x: int = 1;
        {
            let x: int = 2;
        }
    }
    {
        let x: int = 1;
        {
            let x: int = 2; // ERROR
        }
        let y: int = x;
    }
    {
        let x: int = 1;
        {
            var x: int = 2; // ERROR
        }
    }
    {
        var x: int = 1;
        {
            let x: int = 2; // ERROR
        }
    }
    {
        var x: int = 1;
        {
            var x: int = 2; // ERROR
        }
    }
}

public fn value_type_not_shadowing()
{
    {
        var x: int = 1;
    }
    {
        var x: int = 2;
    }
}

public fn value_type_control_flow_not_rebinding(c: bool)
{
    if c
    {
        let x: int = 1;
        return;
    }

    let x: int = 2;
}

public class Test
{
}

public fn reference_type_rebinding()
{
    {
        let x: Test = new Test();
        let x: Test = new Test();
    }
    {
        let x: Test = new Test();
        var x: Test = new Test(); // ERROR
    }
    {
        var x: Test = new Test();
        let x: Test = new Test(); // ERROR
    }
    {
        var x: Test = new Test();
        var x: Test = new Test(); // ERROR
    }
}

public fn reference_type_shadowing()
{
    {
        let x: Test = new Test();
        {
            let x: Test$owned = new Test();
        }
    }
    {
        let x: Test = new Test();
        {
            let x: Test = new Test(); // ERROR let can't shadow when outer let is used after end of scope
        }
        let y: Test = x;
    }
    {
        let x: Test = new Test();
        {
            var x: Test = new Test(); // ERROR var can't shadow let
        }
    }
    {
        var x: Test = new Test();
        {
            let x: Test = new Test(); // ERROR let can't shadow var
        }
    }
    {
        var x: Test = new Test();
        {
            var x: Test = new Test(); // ERROR var can't shadow var
        }
    }
}

public fn reference_type_not_shadowing()
{
    {
        var x: Test = new Test();
    }
    {
        var x: Test = new Test();
    }
}

public fn reference_type_control_flow_not_rebinding(c: bool)
{
    if c
    {
        let x: int = 1;
        return;
    }

    let x: int = 2;
}
